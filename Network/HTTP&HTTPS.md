参考连接：https://www.jianshu.com/p/29e0ba31fb8d



# HTTPS（1.2）



### 预备知识

HTTPS ： 由 HTTP 加上 TLS/SSL 协议构建的可进行加密传输、身份认证的网络协议，主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。

TLS： IETF将SSL进行标准化，1999年公布第一版TLS标准文件,TLS协议的优势是与高层的应用层协议（如HTTP、FTP、Telnet等）无耦合。




## HTTPS 交互概览

3RTT 时间

![image-20220621191550200](https://typroa-pic-sh-1258186845.cos.ap-shanghai.myqcloud.com/202206211915241.png)



## HTTPS 需要解决的三个问题

信息安全问题：1. 保证加密性。2.保证完整性。3.身份识别

### 加密性：

​    通用的方法是使用非对称加密+对称加密来完成。客户端使用公钥对对称加密的密钥进行加密，然后传递给服务端，服务端使用私钥进行解密确认密钥，开始传输数据。

- 对称加密【运算快】：

​      双方持有相同的密钥进行通信。 如AES，ChaCha20

​	对称加密还有分组模式，可以让算法的固定长度的密钥加密任意长度明文，形成密文，常用的有GCM、CCM

​      缺点：如何保证密钥不被破解

- 非对称加密【运算慢】：

​      公钥能解私钥，私钥能解公钥。如DH、RSA、ECC（省带宽

 、内存）

  

### 信息完整性：

​    散列算法：

​      客户端使用公钥加密的该内容的hash值与原始内容，服务端使用私钥进行解密获得原始内容和摘要值。

​    ![image-20220621191754895](https://typroa-pic-sh-1258186845.cos.ap-shanghai.myqcloud.com/202206211917942.png)

  

###  身份识别：

​    发送将发送私钥加密好的数据，并传送公钥给接收方，接收方收到了公钥便可以解密密文，自然认证了发送方的身份。

​    存在问题： 如果传输公钥过程中，被第三方劫持并伪造一对非对称密钥，第三方拥有自己的伪造的私钥和服务端发送的公钥，作中间人劫持

   解决方案：

​    数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等。

   如何保证证书的不被中间人伪造？

  数字证书（证书内容，散列算法，加密密文）在传输过程中使用CA机构提供的私钥加密。

  浏览器中有内置CA机构证书公钥，会验证证书是否为权威机构发放，完成了身份验证。 对于服务端发来的数字证书进行证书公钥解密，解密后的密文有hash值， 解密后的证书内容和hash算法运算得到另一个hash值，比对后 一致表明证书内容是CA机构颁发的合法的证书，完成了公钥传输

  特点： 依赖权威机构的权威性。



## 建立过程：



HTTP建立

（1RTT）

1. 客户端发送SSL 版本号，加密算法种类，**客户端随机数C**。【密钥交换算法+签名算法+对称加密算法+摘要算法】

2. 服务端返回确认的SSL 版本号，支持的加密算法种类，数字证书还有**服务端随机数S和服务端的公钥SP和私钥签名**。S

1RTT

   3. 证书验证逻辑见上文 

4. 证书验证通过，客户端发送客户端公钥给服务端

此时 客户端和服务端都拥有随机数C，随机数S，还有一致的加密算法。此时两端通过密钥交换算法对各自的随机数进行加密，在随机数C、S进行PDF加密，得出主密钥

1RTT

6. 客户端使用加摘要算法对之前的内容进行摘要，并用会话公钥加密，发送给服务端

7. 之后的数据传送都使用会话密钥加密传输

​    

​    ![image-20220621193139019](https://typroa-pic-sh-1258186845.cos.ap-shanghai.myqcloud.com/202206211933525.png)



















## HTTP

Http版本升级：
![image-20220621211926837](C:/Users/92175/AppData/Roaming/Typora/typora-user-images/image-20220621211926837.png)

> Http 1. 0 : 
>
> \1. 事务一次结束后连接关闭，默认不支持长连接（请求结束）
>
> \2. 同步阻塞问题，请求队列的第一个请求因为服务器正忙（或请求格式问题等其他原因），导致后面的请求被阻塞。（未请求）
>
> 
>
> Http1.1:
>
>   \1. 默认开启持久连接，并且允许管道化， 即客户端可以排队发送数据请求无需等待响应，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能 够区分出每次请求的响应内容。
>
> 缺点： 如果某一个响应慢，会影响后面的响应发送（不允许响应插队）。
>
>   \2. 支持只发送头部数据。节省带宽
>
>   \3. 支持断点传输
>
>   \4. 支持host 域
>
> 
>
> Http2.0：
>
> 应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧
>
>   \1. 采用二进制流进行数据传输，数据被分割成多个帧，帧上有流id，每个请求代表一个流 ，所有传输的数据都会被分割
>
>   \2. 多路复用，这意味着HTTP 2.0的通信都在一个连接上完成了，这个连接可以并发承载任意数量的双向数据流，无需浏览器开启多个tcp连接（解决线头阻塞问题）
>
>   \3. 压缩消息头，开启http连接后具有消息头缓存
>
>   \4. 消息具有优先级
>
>   \5. 服务器可以主动推送数据
>
>   \6. 更安全，HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。
>
> 这种改变从根本上解决了阻塞问题，快的响应可以先返回，快的请求可以先处理，最终响应的顺序还是和请求数据时的顺序一致